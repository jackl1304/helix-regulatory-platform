{"version":3,"file":"cachingService.js","sourceRoot":"","sources":["../../server/services/cachingService.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from './logger.service';\n\nconst logger = new Logger('CachingService');\n\ninterface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n  ttl: number;\n}\n\n/**\n * In-memory caching service for API responses and database queries\n * Implements TTL-based expiration and memory-efficient storage\n */\nexport class CachingService {\n  private static instance: CachingService;\n  private cache = new Map<string, CacheEntry<any>>();\n  private readonly maxCacheSize = 1000; // Prevent memory overflow\n  private cleanupInterval: NodeJS.Timeout;\n\n  private constructor() {\n    // Cleanup expired entries every 5 minutes\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupExpiredEntries();\n    }, 5 * 60 * 1000);\n\n    logger.info('Caching service initialized', { maxCacheSize: this.maxCacheSize });\n  }\n\n  static getInstance(): CachingService {\n    if (!CachingService.instance) {\n      CachingService.instance = new CachingService();\n    }\n    return CachingService.instance;\n  }\n\n  /**\n   * Get cached data if valid and not expired\n   */\n  get<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n\n    const now = Date.now();\n    if (now - entry.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      logger.debug('Cache entry expired and removed', { key });\n      return null;\n    }\n\n    logger.debug('Cache hit', { key });\n    return entry.data as T;\n  }\n\n  /**\n   * Set cached data with TTL in milliseconds\n   */\n  set<T>(key: string, data: T, ttlMs: number = 5 * 60 * 1000): void {\n    // Prevent cache from growing too large\n    if (this.cache.size >= this.maxCacheSize) {\n      this.evictOldestEntries(Math.floor(this.maxCacheSize * 0.1)); // Remove 10%\n    }\n\n    const entry: CacheEntry<T> = {\n      data,\n      timestamp: Date.now(),\n      ttl: ttlMs\n    };\n\n    this.cache.set(key, entry);\n    logger.debug('Cache entry set', { key, ttlMs, cacheSize: this.cache.size });\n  }\n\n  /**\n   * Delete specific cache entry\n   */\n  delete(key: string): boolean {\n    const deleted = this.cache.delete(key);\n    if (deleted) {\n      logger.debug('Cache entry deleted', { key });\n    }\n    return deleted;\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clear(): void {\n    const previousSize = this.cache.size;\n    this.cache.clear();\n    logger.info('Cache cleared', { previousSize });\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats() {\n    return {\n      size: this.cache.size,\n      maxSize: this.maxCacheSize,\n      entries: Array.from(this.cache.keys())\n    };\n  }\n\n  /**\n   * Cached wrapper for async functions\n   */\n  async cached<T>(\n    key: string, \n    asyncFn: () => Promise<T>, \n    ttlMs: number = 5 * 60 * 1000\n  ): Promise<T> {\n    // Try to get from cache first\n    const cached = this.get<T>(key);\n    if (cached !== null) {\n      return cached;\n    }\n\n    // Execute function and cache result\n    try {\n      const result = await asyncFn();\n      this.set(key, result, ttlMs);\n      return result;\n    } catch (error) {\n      logger.error('Error in cached function execution', { key, error });\n      throw error;\n    }\n  }\n\n  private cleanupExpiredEntries(): void {\n    const now = Date.now();\n    let removedCount = 0;\n\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > entry.ttl) {\n        this.cache.delete(key);\n        removedCount++;\n      }\n    }\n\n    if (removedCount > 0) {\n      logger.debug('Cleaned up expired cache entries', { \n        removedCount, \n        remainingSize: this.cache.size \n      });\n    }\n  }\n\n  private evictOldestEntries(count: number): void {\n    const entries = Array.from(this.cache.entries())\n      .sort((a, b) => a[1].timestamp - b[1].timestamp)\n      .slice(0, count);\n\n    for (const [key] of entries) {\n      this.cache.delete(key);\n    }\n\n    logger.debug('Evicted oldest cache entries', { \n      evictedCount: count, \n      remainingSize: this.cache.size \n    });\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n    this.cache.clear();\n    logger.info('Caching service destroyed');\n  }\n}\n\nexport const cachingService = CachingService.getInstance();"]}