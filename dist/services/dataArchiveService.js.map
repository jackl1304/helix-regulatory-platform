{"version":3,"file":"dataArchiveService.js","sourceRoot":"","sources":["../../server/services/dataArchiveService.ts"],"names":[],"mappings":"AAQA,MAAM,OAAO,kBAAkB;IAG7B;QAFiB,eAAU,GAAG,YAAY,CAAC;QAGzC,OAAO,CAAC,GAAG,CAAC,yCAAyC,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC;IAC1E,CAAC;IAKD,gBAAgB,CAAC,WAAmB;QAClC,OAAO,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAC3D,CAAC;IAKD,oBAAoB;QAClB,OAAO,oBAAoB,IAAI,CAAC,UAAU,GAAG,CAAC;IAChD,CAAC;IAKD,uBAAuB;QACrB,OAAO,mBAAmB,IAAI,CAAC,UAAU,GAAG,CAAC;IAC/C,CAAC;IAKD,eAAe,CAAC,YAAoB,EAAE,cAAsB;QAM1D,MAAM,QAAQ,GAAG,YAAY,GAAG,cAAc,CAAC;QAC/C,MAAM,eAAe,GAAG,CAAC,CAAC,QAAQ,GAAG,YAAY,CAAC,GAAG,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAErE,OAAO;YACL,KAAK,EAAE,YAAY;YACnB,OAAO,EAAE,cAAc;YACvB,QAAQ;YACR,eAAe,EAAE,GAAG,eAAe,yBAAyB;SAC7D,CAAC;IACJ,CAAC;IAKD,KAAK,CAAC,cAAc,CAAC,GAAQ;QAI3B,IAAI,CAAC;YACH,OAAO,CAAC,GAAG,CAAC,oDAAoD,IAAI,CAAC,UAAU,MAAM,CAAC,CAAC;YAGvF,MAAM,eAAe,GAAG,MAAM,GAAG,CAAA;;;+BAGR,IAAI,CAAC,UAAU;OACvC,CAAC;YAGF,MAAM,eAAe,GAAG,MAAM,GAAG,CAAA;;;gCAGP,IAAI,CAAC,UAAU;OACxC,CAAC;YAEF,MAAM,QAAQ,GAAG,QAAQ,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YACpD,MAAM,SAAS,GAAG,QAAQ,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YAErD,OAAO,CAAC,GAAG,CAAC,uCAAuC,CAAC,CAAC;YACrD,OAAO,CAAC,GAAG,CAAC,sCAAsC,IAAI,CAAC,UAAU,MAAM,QAAQ,EAAE,CAAC,CAAC;YACnF,OAAO,CAAC,GAAG,CAAC,kCAAkC,IAAI,CAAC,UAAU,MAAM,SAAS,EAAE,CAAC,CAAC;YAChF,OAAO,CAAC,GAAG,CAAC,yCAAyC,CAAC,CAAC,QAAQ,GAAG,CAAC,QAAQ,GAAG,SAAS,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YAEhH,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC;QACjC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,oCAAoC,EAAE,KAAK,CAAC,CAAC;YAC3D,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;CACF;AAED,MAAM,CAAC,MAAM,cAAc,GAAG,IAAI,kBAAkB,EAAE,CAAC","sourcesContent":["// Data Archive Service - Intelligente Datenarchivierung nach Datum\n// Optimiert Performance durch Trennung von aktuellen und historischen Daten\n\ninterface ArchiveConfig {\n  cutoffDate: string;\n  archiveOlderThan: number; // Tage\n}\n\nexport class DataArchiveService {\n  private readonly cutoffDate = '2024-06-01';\n  \n  constructor() {\n    console.log(`[ARCHIVE] Initialisiert mit Stichtag: ${this.cutoffDate}`);\n  }\n\n  /**\n   * Bestimmt ob Daten archiviert oder aktuell sind\n   */\n  isHistoricalData(publishedAt: string): boolean {\n    return new Date(publishedAt) < new Date(this.cutoffDate);\n  }\n\n  /**\n   * Erstellt Filter für aktuelle Daten (Regulatory Updates)\n   */\n  getCurrentDataFilter(): string {\n    return `published_at >= '${this.cutoffDate}'`;\n  }\n\n  /**\n   * Erstellt Filter für historische Daten\n   */\n  getHistoricalDataFilter(): string {\n    return `published_at < '${this.cutoffDate}'`;\n  }\n\n  /**\n   * Performance-Statistiken\n   */\n  getArchiveStats(totalUpdates: number, currentUpdates: number): {\n    total: number;\n    current: number;\n    archived: number;\n    performanceGain: string;\n  } {\n    const archived = totalUpdates - currentUpdates;\n    const performanceGain = ((archived / totalUpdates) * 100).toFixed(1);\n    \n    return {\n      total: totalUpdates,\n      current: currentUpdates,\n      archived,\n      performanceGain: `${performanceGain}% weniger Datentransfer`\n    };\n  }\n\n  /**\n   * Migriert alte Daten zu historischen Daten\n   */\n  async archiveOldData(sql: any): Promise<{\n    archived: number;\n    remaining: number;\n  }> {\n    try {\n      console.log(`[ARCHIVE] Starte Archivierung älterer Daten (vor ${this.cutoffDate})...`);\n      \n      // Zähle Updates vor Stichtag\n      const oldUpdatesCount = await sql`\n        SELECT COUNT(*) as count \n        FROM regulatory_updates \n        WHERE published_at < ${this.cutoffDate}\n      `;\n      \n      // Zähle Updates nach Stichtag  \n      const newUpdatesCount = await sql`\n        SELECT COUNT(*) as count \n        FROM regulatory_updates \n        WHERE published_at >= ${this.cutoffDate}\n      `;\n      \n      const archived = parseInt(oldUpdatesCount[0].count);\n      const remaining = parseInt(newUpdatesCount[0].count);\n      \n      console.log(`[ARCHIVE] Archivierung abgeschlossen:`);\n      console.log(`[ARCHIVE] - Archivierte Daten (vor ${this.cutoffDate}): ${archived}`);\n      console.log(`[ARCHIVE] - Aktuelle Daten (ab ${this.cutoffDate}): ${remaining}`);\n      console.log(`[ARCHIVE] - Performance-Verbesserung: ${((archived / (archived + remaining)) * 100).toFixed(1)}%`);\n      \n      return { archived, remaining };\n    } catch (error) {\n      console.error('[ARCHIVE] Fehler bei Archivierung:', error);\n      throw error;\n    }\n  }\n}\n\nexport const archiveService = new DataArchiveService();"]}