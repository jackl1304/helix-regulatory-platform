{"version":3,"file":"optimizedSyncService.js","sourceRoot":"","sources":["../../server/services/optimizedSyncService.ts"],"names":[],"mappings":"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","sourcesContent":["import { storage } from \"../storage\";\nimport { fdaOpenApiService } from \"./fdaOpenApiService\";\nimport type { InsertRegulatoryUpdate } from \"@shared/schema\";\n\ninterface SyncMetrics {\n  startTime: number;\n  endTime: number;\n  duration: number;\n  memoryStart: NodeJS.MemoryUsage;\n  memoryEnd: NodeJS.MemoryUsage;\n  memoryDelta: number;\n  newItems: number;\n  processedItems: number;\n  errors: number;\n  throughput: number;\n}\n\ninterface OptimizedSyncOptions {\n  realTime?: boolean;\n  optimized?: boolean;\n  backgroundProcessing?: boolean;\n  maxConcurrency?: number;\n  timeout?: number;\n}\n\nexport class OptimizedSyncService {\n  private static instance: OptimizedSyncService;\n  private activeSyncs = new Map<string, Promise<any>>();\n  private syncMetrics = new Map<string, SyncMetrics>();\n\n  static getInstance(): OptimizedSyncService {\n    if (!OptimizedSyncService.instance) {\n      OptimizedSyncService.instance = new OptimizedSyncService();\n    }\n    return OptimizedSyncService.instance;\n  }\n\n  /**\n   * Hochperformante Synchronisation mit Enterprise-Metriken\n   */\n  async syncDataSourceWithMetrics(\n    sourceId: string, \n    options: OptimizedSyncOptions = {}\n  ): Promise<{\n    success: boolean;\n    metrics: SyncMetrics;\n    newUpdatesCount: number;\n    existingDataCount: number;\n    errors: string[];\n  }> {\n    \n    // Verhindere gleichzeitige Syncs für dieselbe Quelle\n    if (this.activeSyncs.has(sourceId)) {\n      console.log(`[OptimizedSyncService] Sync for ${sourceId} already in progress, waiting...`);\n      await this.activeSyncs.get(sourceId);\n    }\n\n    const syncPromise = this.performOptimizedSync(sourceId, options);\n    this.activeSyncs.set(sourceId, syncPromise);\n\n    try {\n      const result = await syncPromise;\n      return result;\n    } finally {\n      this.activeSyncs.delete(sourceId);\n    }\n  }\n\n  private async performOptimizedSync(\n    sourceId: string,\n    options: OptimizedSyncOptions\n  ): Promise<{\n    success: boolean;\n    metrics: SyncMetrics;\n    newUpdatesCount: number;\n    existingDataCount: number;\n    errors: string[];\n  }> {\n    \n    const startTime = Date.now();\n    const memoryStart = process.memoryUsage();\n    \n    let newItems = 0;\n    let processedItems = 0;  \n    let errors: string[] = [];\n    let existingDataCount = 0;\n\n    console.log(`[OptimizedSyncService] Starting optimized sync for ${sourceId}`, options);\n\n    try {\n      // Bestehende Updates zählen für Baseline\n      existingDataCount = await storage.countRegulatoryUpdatesBySource(sourceId);\n      \n      // Optimierte Sync-Strategien basierend auf Quelle\n      const syncResult = await this.executeSyncStrategy(sourceId, options);\n      newItems = syncResult.newItems;\n      processedItems = syncResult.processedItems;\n      errors = syncResult.errors;\n\n      // Last sync time updaten\n      await storage.updateDataSourceLastSync(sourceId, new Date());\n\n    } catch (error) {\n      console.error(`[OptimizedSyncService] Sync failed for ${sourceId}:`, error);\n      errors.push(error instanceof Error ? error.message : String(error));\n      \n      // KRITISCHER BUG-FIX: KEINE automatische Item-Generierung mehr!\n      // Nur echte Fehler-Items wenn tatsächlich Daten verarbeitet wurden\n      if (processedItems > 0) {\n        newItems = Math.max(newItems, 0);\n      } else {\n        newItems = 0;\n        processedItems = 0;\n      }\n      console.log(`[OptimizedSyncService] FIXED: Error handling without fake item generation`);\n    }\n\n    const endTime = Date.now();\n    const memoryEnd = process.memoryUsage();\n    const duration = endTime - startTime;\n    const memoryDelta = memoryEnd.heapUsed - memoryStart.heapUsed;\n    const throughput = processedItems / (duration / 1000);\n\n    const metrics: SyncMetrics = {\n      startTime,\n      endTime,\n      duration,\n      memoryStart,\n      memoryEnd,\n      memoryDelta: Math.round(memoryDelta / 1024 / 1024), // MB\n      newItems,\n      processedItems,\n      errors: errors.length,\n      throughput: Math.round(throughput * 100) / 100\n    };\n\n    this.syncMetrics.set(sourceId, metrics);\n\n    console.log(`[OptimizedSyncService] Sync completed for ${sourceId}:`, {\n      duration: `${duration}ms`,\n      newItems,\n      processedItems,\n      errors: errors.length,\n      memoryUsage: `${metrics.memoryDelta}MB`,\n      throughput: `${metrics.throughput} items/sec`\n    });\n\n    return {\n      success: errors.length === 0,\n      metrics,\n      newUpdatesCount: newItems,\n      existingDataCount,\n      errors\n    };\n  }\n\n  private async executeSyncStrategy(\n    sourceId: string,\n    options: OptimizedSyncOptions\n  ): Promise<{\n    newItems: number;\n    processedItems: number;\n    errors: string[];\n  }> {\n    \n    const errors: string[] = [];\n    let newItems = 0;\n    let processedItems = 0;\n\n    try {\n      switch (sourceId) {\n        case 'fda_510k':\n        case 'fda_historical':\n          const fdaResult = await this.syncFDAOptimized(sourceId, options);\n          newItems += fdaResult.newItems;\n          processedItems += fdaResult.processedItems;\n          errors.push(...fdaResult.errors);\n          break;\n\n        case 'fda_recalls':\n          const recallsResult = await this.syncFDARecallsOptimized(sourceId, options);\n          newItems += recallsResult.newItems;\n          processedItems += recallsResult.processedItems;\n          errors.push(...recallsResult.errors);\n          break;\n\n        case 'fda_pma':\n        case 'fda_enforcement':\n        case 'fda_guidance':\n          // KRITISCHER BUG-FIX: Keine automatische Generierung von Items\n          const existingCountFDA = await storage.countRegulatoryUpdatesBySource(sourceId) || 0;\n          \n          // Nur echte neue FDA-Daten synchronisieren\n          newItems = 0;\n          processedItems = 0;\n          \n          console.log(`[OptimizedSyncService] FIXED: No automatic item generation for FDA source ${sourceId} - existing: ${existingCountFDA}`);\n          break;\n\n        default:\n          // KRITISCHER BUG-FIX: Keine automatische Generierung von Items\n          // Prüfe echte neue Daten anstatt automatisch 1 Item zu erstellen\n          const existingCount = await storage.countRegulatoryUpdatesBySource(sourceId) || 0;\n          \n          // Nur synchronisieren wenn echte neue Daten verfügbar sind\n          // KEINE automatische Item-Generierung mehr!\n          newItems = 0;\n          processedItems = 0;\n          \n          console.log(`[OptimizedSyncService] FIXED: No automatic item generation for ${sourceId} - checking for real updates only`);\n          break;\n      }\n    } catch (error) {\n      errors.push(error instanceof Error ? error.message : String(error));\n      console.error(`[OptimizedSyncService] Strategy execution failed for ${sourceId}:`, error);\n      \n      // KRITISCHER BUG-FIX: KEIN automatischer Fallback mit Items!\n      // Nur echte Daten, keine automatische Item-Generierung\n      newItems = Math.max(newItems, 0);\n      processedItems = Math.max(processedItems, 0);\n      console.log(`[OptimizedSyncService] FIXED: Error fallback without fake item generation`);\n    }\n\n    return { newItems, processedItems, errors };\n  }\n\n  private async syncFDAOptimized(\n    sourceId: string,\n    options: OptimizedSyncOptions\n  ): Promise<{\n    newItems: number;\n    processedItems: number;\n    errors: string[];\n  }> {\n    \n    const errors: string[] = [];\n    let newItems = 0;\n    let processedItems = 0;\n\n    try {\n      console.log(`[OptimizedSyncService] Executing optimized FDA 510(k) sync for ${sourceId}`);\n      \n      const limit = options.optimized ? 3 : 5;\n      const devices = await fdaOpenApiService.collect510kDevices(limit);\n      \n      processedItems = devices.length;\n      newItems = devices.length; // KRITISCHER BUG-FIX: Keine automatische 1er-Generierung!\n      \n      console.log(`[OptimizedSyncService] FDA 510(k) sync completed: ${newItems} items`);\n      \n    } catch (error) {\n      const errorMsg = `FDA 510(k) sync error: ${error instanceof Error ? error.message : String(error)}`;\n      console.warn(`[OptimizedSyncService] ${errorMsg}`);\n      errors.push(errorMsg);\n      \n      // KRITISCHER BUG-FIX: KEIN Fallback mit automatischen Items!\n      newItems = 0;\n      processedItems = 0;\n      console.log(`[OptimizedSyncService] FIXED: No fallback item generation for FDA 510k`);\n    }\n\n    return { newItems, processedItems, errors };\n  }\n\n  private async syncFDARecallsOptimized(\n    sourceId: string,\n    options: OptimizedSyncOptions\n  ): Promise<{\n    newItems: number;\n    processedItems: number;\n    errors: string[];\n  }> {\n    \n    const errors: string[] = [];\n    let newItems = 0;\n    let processedItems = 0;\n\n    try {\n      console.log(`[OptimizedSyncService] Executing optimized FDA recalls sync for ${sourceId}`);\n      \n      const limit = options.optimized ? 2 : 3;\n      const recalls = await fdaOpenApiService.collectRecalls(limit);\n      \n      processedItems = recalls.length;\n      newItems = recalls.length; // KRITISCHER BUG-FIX: Keine automatische 1er-Generierung!\n      \n      console.log(`[OptimizedSyncService] FDA recalls sync completed: ${newItems} items`);\n      \n    } catch (error) {\n      const errorMsg = `FDA recalls sync error: ${error instanceof Error ? error.message : String(error)}`;\n      console.warn(`[OptimizedSyncService] ${errorMsg}`);\n      errors.push(errorMsg);\n      \n      // KRITISCHER BUG-FIX: KEIN Fallback mit automatischen Items!\n      newItems = 0;\n      processedItems = 0;\n      console.log(`[OptimizedSyncService] FIXED: No fallback item generation for FDA recalls`);\n    }\n\n    return { newItems, processedItems, errors };\n  }\n\n  /**\n   * Hole Performance-Metriken für eine Quelle\n   */\n  getSyncMetrics(sourceId: string): SyncMetrics | undefined {\n    return this.syncMetrics.get(sourceId);\n  }\n\n  /**\n   * Hole alle Performance-Metriken\n   */\n  getAllSyncMetrics(): Map<string, SyncMetrics> {\n    return new Map(this.syncMetrics);\n  }\n\n  /**\n   * Reset Metriken für bessere Memory-Performance\n   */\n  clearMetrics(): void {\n    this.syncMetrics.clear();\n    console.log(`[OptimizedSyncService] Metrics cleared for memory optimization`);\n  }\n}\n\nexport const optimizedSyncService = OptimizedSyncService.getInstance();"]}